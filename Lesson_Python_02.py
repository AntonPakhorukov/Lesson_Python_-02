# КОНСТРУКЦИЯ 1: =======================================================================================================================

colors = ['red-', 'green-', 'blue'] # Есть некие данные, в роли которых будети выступать список
data = open('file.txt', 'a') # создаем текстовую переменную 'data' и связываем ее с текстовым файлом
# 'file.txt' - здесь указываем путь к файлу, 'a' - здесь указываем мод (a - дозапись, r - чтение, w - запись)
data.writelines(colors) # далее есть функционал, например writeline - который позволяет записать некоторый набор данных
# и в качестве аргумента передаем набор данных 'сcolors' (без разделителей)
data.write('\nLINE 2\n') # Первую строку закомитили - пустая, сделали '\n', написали на второй строке
data.write('LINE 3 \n') # Написали на третьей строчке
data.close() # после окончания работы с файлом его нужно закрыть - во избежание утечек памяти
# После запуска программы появился файл 'file.txt' с записью 'redgreenblue', при повторном запуске 'redgreenblueredgreenblue'

# КОНСТРУКЦИЯ 2: ======================================================================================================================

with open('file2.txt', 'w') as data: # 'as data' - воспринимает некую конструкцию ('file2.txt', 'w') как некую переменную 'data'
    data.writelines('LINE_01\n')
    data.write('LINE_02\n')
# После выполнения строк 'data.write' произойдет разрыв между переменной data и файлом file2.txt

# ЧТЕНИЕ ИЗ ФАЙЛА: ====================================================================================================================

path = 'file2.txt' # Создадим путь к нашей папке
data = open(path, 'r') # Откроем файл в режиме чтения (r)
for line in data: # с помощью цикла пробежимся по файлу и считаем все строки
    print(line)
data.close() # после того, как закончили чтение, разорвем связь

# ФУНКЦИИ И МЕТОДЫ: ====================================================================================================================

import function
print(function.f(1)) # Использует функцию f(x) из файла function
# function - название файла, f - название функции, 1 - аргумент

import funct as h # 'as h' - альяс используется для того, чтобы каждый раз не писать 'funct', а поставить просто 'h'
print(h.f(2.3)) # используем псевдоним 'h'

# В python можно перемножасть строку на число =========================================================================================
# Ver.1:
def new_string(symbol, count):
    return symbol * count
print(new_string(':-)', 3))
# print(new_string('!')) # без второго аргумента выдаст ошибку
# Ver.2:
def new_test(s, v):
    return s * v
print(new_test(3, 'f'))
# Ver.3:
def test3(sym, val = 3): # задавая значение одного аргумента, в выводе можно его уже не писать
    return sym * val
print(test3('s', 5))
# print(test3('w')) # при одном аргументе не выдаст ошибки
print(test3(4))

# Передача неограниченного количества аргументов функции ==============================================================================

def concatenatio(*params): # для передачи негораниченного количества аргументов, перед названием ставится '*'
    res: str = "" # пишем переменную и указываем тип данных (можно просто указать  res = "")
    for item in params: # циклом считываем значение аргументов
        res += item # для вывода используем склеивание строк
    return res
print(concatenatio('a','s','d','w'))
print(concatenatio('a','1','d','2'))
# print(concatenatio(1, 2, 3, 4, 5)) # выдаст ошибку, так ранее указывали, что будет тип данный строка

def celvalues(*args): # название функции и аргумента может быть любым
    val: int = 0 # указываем, что ждем на выходе числа (можно просто указать val = 0)
    for i in args:
        val += i
    return val
print(celvalues(1, 2, 3, 4, 5)) # ошибки не будет, выдаст сумму 15

# РЕКУРСИЯ ===========================================================================================================================

def fib(n): # создаем функцию
    if n in [1, 2]: # если аргумент равен 1 или 2, то возвращаем 1
        return 1
    else:
        return fib(n - 1) + fib(n - 2) # если аргумент больше 2, то запускается рекурсия
list = []
for e in range(1, 10):
    list.append(fib(e))
print(list)

# КОРТЕЖИ - ЭТО НЕИЗМЕНЯЕМЫЙ СПИСОК ==================================================================================================

# обычное множественное присваивание:
a, b = 3, 4 # или x, y = (5, 6) -> класс int
print(f' a = {a}, b = {b}') # Выведет a = 3, b = 4
print(type(a)) # класс int

# Кортеж:
a = (7, 8, 9, 10)
print(f'a = {a}') # выведет a = (7, 8)
print(f'a[0] = {a[0]}') # выведет a[0] = 7
print(type(a)) # класс кортеж (tuple)
print(a[-1]) # выведет 10
print(a[-2]) # выведет 9 - работает по аналогии со списками
# a[0] = 17 # если попытаемс 0-у элементу присвоить другое значение, выдаст ошибку, работает только со списками
# поэтому, кортеж определяем как не изменяемый список

for item in a:
    print(item, end=' ')
print()
print(a)

s = tuple(['red','green','black'])
print(s[1])
print(type(s))
s1 = ('blue','yelow','orange')
print(s1[2])
print(type(s1))
s2 = ('red', 1, 'blue', 2) # картежи как списки, могут содержать разные типы переменных
print(s2[0])
print(s2[3])
print(type(s2))

# конвертация в список: ===============================
list = []
for i in a:
    list.append(i)
print(list)
print(type(list))

print(s)
for i in s:
    print(i, end=' ')
print()

# распаковка кортежа в отдельные переменные ==========
colors = tuple(['white','dark','skyblue']) # 1. СОЗДАЕМ СПИСОК И ПРЕВРАЩАЕМ ЕГО В КОРТЕЖ
print(type(colors)) # кортеж
white, dark, skyblue = colors # 2. РАСПАКОВЫВАЕМ КОРТЕЖ И ПРЕВРАЩАЕМ ЕГО В 3 НЕЗАВИСИМЫХ ПЕРЕМЕННЫХ
# без этой распаковки выдаст ошибку 'NameError'
# прописали цвета и присвоили переменной 'colors' типа кортеж, которая была определена на основе списка
print('w: {} d: {} s: {}'.format(white, dark, skyblue)) # 3. ДАЛЕЕ РАБОТАЕМ КАК С ОТДЕЛЬНЫМИ ПЕРЕМЕННЫМИ 
# w: white d: dark s: skyblue
print('w: {} d: {} s: {}'.format(1, 2, 3)) 
# w: 1 d: 2 s: 3 - можно задать любые значения

values = ('first','second','third')
print(type(values)) # кортеж
values2 = ['list1','list2','list3']
print(values2)
print(type(values2)) # список
one, two, three = values
print('f: {} s: {} t: {}'.format(1, 2, 3))

list = ['one','two','three', 1, 2, 3]
print(list)
print(type(list)) # список
print(list[0])
print(list[1][1])
cortege = tuple(list)
print(cortege)
print(type(cortege)) # кортеж
print(cortege[0])
print(cortege[1][1]) # работает одинакого на списках и кортежах

# СЛОВАРИ - НЕУПОРЯДОЧЕННЫЕ КОЛЛЕКЦИИ ПРОИЗВОЛЬНЫХ ОБЪЕКТОВ С ДОСТУПОМ ПО КЛЮЧУ ======================================================

dictionary = {} # Создали пустой словарь
dictionary = \
    {
        'up': '↑', 'left': '←', 'right': '→', 'down': '↓'
    }
# '\' - сделали привязку ключ: значение
print(type(dictionary)) # класс 'DICT'ionar - словарь
print(dictionary) # вывод всего списка-
print(dictionary['up']) # обращение к ключу
dictionary['up'] = 'Вверх' # Можно менять содержимое словаря по ключу (как со списками)
print(dictionary)

# МНОЖЕСТВА - НЕУПОРЯДОЧЕННАЯ КОЛЛЕКЦИЯ УНИКАЛЬНЫЕ ЭЛЕМЕНТЫ ==========================================================================

color = {'orange', 'dark', 'white', 'blue', 'green'} # множество можно создать только перечислением, иначе буде словарь
print(type(color)) # класс 'SET's - множества
print(color) # выводить будет не по порядку (неупорядоченная коллекция) - {'white', 'blue', 'green', 'orange', 'dark'}
color.add('red') # так можно дабавить элемент в множество
print(color) # {'white', 'blue', 'red', 'green', 'orange', 'dark'}
color.add('red') # повторно элемент не добавится, так как множество состоит из уникальных элементов
print(color)
color.remove('blue') # так можно удалять элемент из множества
print(color)
#color.remove('blue') # так выдаст ошибку, так как такого элемента уже нет
color.discard('white') # так тоже можно удалять элемент, при чем, если такого элемента нет - ошибку не выдаст
print(color)
color.discard('white') # ошибки нет
print(color)
color.clear() # полностью удалит все элементы
print(color) # выдаст set()

fruit = set()
print(type(fruit))
fruit.add('apple')
print(fruit)
fruit.add(1) # может содержать как строку, так и число
print(fruit)
#fruit.add('bananas', 'grypfruit', 'avocado') # можно добавлять только по одному элементу
print(fruit)

# изменяемые множества ================================
a = {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 23}
c = a.copy() # 'a' будет скопировано в 'с'
print(f'a = {a}') # {1, 2, 3, 5, 8}
print(f'b = {b}') # {2, 5, 8, 13, 23}
print(f'c = {c}') # {1, 2, 3, 5, 8}
u = a.union(b) # указываем первое множество, вызываем функцию 'union' (союз - объединение) и выбираем второе множество
print(f'u = {u}') # в 'u' будут объединены элементы двух множеств 'a' и 'b' (без повторения элементов) {1, 2, 3, 5, 8, 13, 23}
i = a.intersection(b) # вывести пересечение множеств - используем функцию 'intersection'
print(f'i = {i}') # Вывод пересечения: {8, 2, 5}
dl = a.difference(b) # difference - разница, выведет элементы, которых нет в 'b' (в левом множестве)
print(f'dl = {dl}') # {1, 3}
dr = b.difference(a) # difference - разница, выведет элементы, которых нет в 'a' (в правом множестве)
print(f'dr = {dr}') # {13, 23}

# пример 2: ==========================================
x = {1, 2, 3, 4, 5}
y = {1, 3, 5, 7, 9}
print(f'x = {x}')
print(f'y = {y}')
q = x \
    .union(y) \
        .difference(x.intersection(y))
print(f'q = {q}') # выведет {9, 2, 4, 7}
# ТЕПЕРЬ ПОДРОБНО:
r1 = x.union(y)
print(f'r1 = {r1} объединили множества')
r2 = x.intersection(y)
print(f'r2 = {r2} пересечение множеств')
r3 = r1.difference(r2)
print(f'r3 = {r3} разница между объединением и пересечением')
test = (x.union(y)).difference(x.intersection(y)) # можно записать в одну строчку
print(test) # {9, 2, 4, 7}

# неизменяемые множества =============================
z = {1, 2, 3, 4, 5} # в 'z' можно использвать функции .add / .remove / .discard
d = {2, 4, 6, 8, 10}
frozen = frozenset(z) # в 'frozen' нельзя использвать функции .add / .remove / .discard
# но можно взаимодецствовать между различными обществами:
print(f'z = {z}') # {1, 2, 3, 4, 5}
print(f'd = {d}')
print(type(z)) # set
print(f'frozen = {frozen}') # frozenset({1, 2, 3, 4, 5})
print(type(frozen)) # frozenset
testF1 = frozen.union(d) # выводит только уникальные элементы множеств
print(f'testF1 = {testF1}')
testF2 = frozen.difference(d) # выведет элементы, которых нет в множестве 'd'
print(f'testF2 = {testF2}')
testF3 = d.difference(frozen) # не будет тип frozenset, так как первое множество стоит 'd', выведет элементы, которых нет в 'frozen'
print(f'testF3 = {testF3}') 
testF4 = frozen.intersection(d) # выведет общие элементы множеств
print(f'testF4 = {testF4}')

# СПИСКИ ==============================================================================================================================

list1 = [1, 2, 3, 4, 5]
list2 = list1
list1[0] = 123 # изменится нулевое индекс в обоих списках
list2[1] = 234 # изменится первый индекс и в исходном списке 'list1'
for i in list1:
    print(i, end=' ')
print()
for j in list2:
    print(j, end=' ')
# ВАЖНАЯ ОСОБЕННОСТЬ 1:
# Если запустить программу, то выдаст одинаковый результат: 1 2 3 4 5 и 1 2 3 4 5
# но если после создания 'list2' изменить нулевой элемент списка 'list1' -> list1[0] = 123, 
# то вывод будет 123 2 3 4 5 и 123 2 3 4 5 -> то есть изменится и нулевое значение второго списка 'list2'
# изменив элемент во втором списке'list2', изменится и элемет в исходном списке 'list1'

list3 = [10, 20, 30, 40, 50]
print(f'list3 = {list3}') # [10, 20, 30, 40, 50]
list3.pop() # удаляет последний элемент из списка
print(f'list3 = {list3}') # [10, 20, 30, 40]
list3.pop()
print(f'list3 = {list3}') # [10, 20, 30]
list3.pop(1) # указав аргумент функции 'pop', можно удалить элемет под конкретным индексом
print(f'list3 = {list3}') # [10, 30]
list3.insert(1, 5) # с помощью функции 'insert' можно вставить элемет в список, указав в аргуметах сперва номер элемента за которым
# будет стоять вставляемый элемент, а следом и сам элемент (что добавляем)
print(f'list3 = {list3}') # [10, 5, 30]
list3.append(9) # добавляет элемент в конец списка
print(f'list3 = {list3}')
print()
list4 = [1, 2, 3, 4, 5]
print(list4)
list4.insert(2, 0)
print(list4)

exit() # позволяет не выполнять тот код, который дальше в скрпите прописан